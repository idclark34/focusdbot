import SwiftUI
import AppKit

struct AppSlice: Identifiable {
    let id = UUID()
    let name: String
    let seconds: Int
    let color: Color
}

final class ReflectionWindowController {
    private let panel: NSPanel

    init(model: BotModel, slices: [AppSlice], sessionId: Int64?) {
        let size = NSSize(width: 320, height: 450) // Increased height for AI summary
        self.panel = NSPanel(contentRect: NSRect(origin: .zero, size: size),
                              styleMask: [.titled, .nonactivatingPanel],
                              backing: .buffered,
                              defer: false)
        panel.level = .floating
        panel.center()
        panel.isReleasedWhenClosed = false
        panel.title = "Session Summary"

        let root = ReflectionView(slices: slices, sessionId: sessionId) { [weak panel] in
            panel?.orderOut(nil)
        }.environmentObject(model)
        let host = NSHostingView(rootView: root)
        host.frame = panel.contentView!.bounds
        host.autoresizingMask = [.width, .height]
        panel.contentView = host
    }

    func show() { panel.makeKeyAndOrderFront(nil) }
}

struct ReflectionView: View {
    let slices: [AppSlice]
    let sessionId: Int64?
    let close: () -> Void
    @State private var note: String = ""
    @State private var aiSummary: String? = nil
    @State private var isLoadingAI: Bool = false
    @EnvironmentObject var model: BotModel

    var body: some View {
        VStack(spacing: 16) {
            Text("Great work! 🍅").font(.title2.bold())

            PieChart(slices: slices)
                .frame(width: 120, height: 120)

            VStack(alignment: .leading, spacing: 4) {
                ForEach(slices) { s in
                    HStack {
                        Circle().fill(s.color).frame(width: 10, height: 10)
                        Text("\(s.name): \(s.seconds/60)m")
                            .font(.caption)
                    }
                }
            }
            
            // AI Summary Section
            if let summary = aiSummary {
                VStack(alignment: .leading, spacing: 8) {
                    HStack {
                        Image(systemName: "sparkles")
                            .foregroundColor(.blue)
                        Text("AI Summary")
                            .font(.headline)
                            .foregroundColor(.blue)
                    }
                    Text(summary)
                        .font(.body)
                        .padding(12)
                        .background(Color(.controlBackgroundColor))
                        .cornerRadius(8)
                }
            } else if isLoadingAI {
                HStack {
                    ProgressView()
                        .scaleEffect(0.8)
                    Text("Generating AI summary...")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }

            TextField("What did you accomplish?", text: $note)
                .textFieldStyle(.roundedBorder)
                .padding(.top, 8)

            Button("OK") {
                if !note.trimmingCharacters(in: .whitespaces).isEmpty {
                    model.sessionSummaries.insert(note, at: 0)
                    if model.sessionSummaries.count > 10 { model.sessionSummaries.removeLast() }
                }
                close()
            }
            .buttonStyle(.borderedProminent)
        }
        .padding(20)
        .onAppear {
            loadAISummary()
        }
    }
    
    private func loadAISummary() {
        guard let sessionId = sessionId else { return }
        
        // First check if summary already exists in database
        Task {
            do {
                let summary = try await fetchExistingAISummary(sessionId: sessionId)
                await MainActor.run {
                    if let summary = summary, !summary.isEmpty {
                        self.aiSummary = summary
                    } else {
                        // Start loading indicator while AI generates summary
                        self.isLoadingAI = true
                        // The summary will be generated by finalizeSession, check periodically
                        startPollingForAISummary(sessionId: sessionId)
                    }
                }
            } catch {
                print("[ReflectionView] Error fetching AI summary: \(error)")
            }
        }
    }
    
    private func startPollingForAISummary(sessionId: Int64) {
        Task {
            // Poll for AI summary for up to 30 seconds
            for _ in 0..<30 {
                try await Task.sleep(nanoseconds: 1_000_000_000) // 1 second
                
                if let summary = try await fetchExistingAISummary(sessionId: sessionId), !summary.isEmpty {
                    await MainActor.run {
                        self.aiSummary = summary
                        self.isLoadingAI = false
                    }
                    return
                }
            }
            
            // Timeout - stop loading indicator
            await MainActor.run {
                self.isLoadingAI = false
            }
        }
    }
    
    private func fetchExistingAISummary(sessionId: Int64) async throws -> String? {
        return try await withCheckedThrowingContinuation { continuation in
            do {
                try DB.shared.read { db in
                    let summary = try String.fetchOne(db, sql: """
                        SELECT aiSummary FROM session WHERE id = ?
                    """, arguments: [sessionId])
                    continuation.resume(returning: summary)
                }
            } catch {
                continuation.resume(throwing: error)
            }
        }
    }
}

struct PieChart: View {
    let slices: [AppSlice]
    var total: Double { Double(slices.reduce(0){$0+$1.seconds}) }

    struct Segment: Identifiable { let id = UUID(); let start: Double; let end: Double; let color: Color }

    private var segments: [Segment] {
        var start: Double = 0
        var segs: [Segment] = []
        for s in slices {
            let end = start + Double(s.seconds)/total
            segs.append(Segment(start: start, end: end, color: s.color))
            start = end
        }
        return segs
    }

    var body: some View {
        ZStack {
            ForEach(segments) { seg in
                PieSlice(start: seg.start, end: seg.end)
                    .fill(seg.color)
            }
        }
    }
}

struct PieSlice: Shape {
    let start: Double // 0-1
    let end: Double
    func path(in rect: CGRect) -> Path {
        var p = Path()
        let center = CGPoint(x: rect.midX, y: rect.midY)
        p.move(to: center)
        p.addArc(center: center, radius: rect.width/2, startAngle: .degrees(start*360-90), endAngle: .degrees(end*360-90), clockwise: false)
        p.closeSubpath()
        return p
    }
} 